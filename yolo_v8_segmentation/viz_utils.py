# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_viz_utils.ipynb.

# %% auto 0
__all__ = ['get_name', 'overlay_mask', 'overlay_mask_border_on_image', 'overlay_yolo_mask']

# %% ../nbs/02_viz_utils.ipynb 4
import cv2
from pathlib import Path
import numpy as np
from fastcore.all import *
import matplotlib.pyplot as plt
import matplotlib as mpl
from scipy.ndimage import binary_dilation, binary_erosion
import matplotlib.patches as patches
import matplotlib as mpl

# %% ../nbs/02_viz_utils.ipynb 6


def overlay_yolo_bbox(
        im_path, 
        msk_path, 
        color=None, # color values other matplotlib colors
        idx=None, # Index of image in the folder other random will be chosen
        im_name=None, # Imge name with extension
        fill=False, # whther to fill the mask or not
        alpha=0.3 # alpha value for the mask for transparency
        ):
    'Creaete a overlay image from image and mask'


    im_idx = idx if idx is not None else np.random.choice(len(im_path.ls()), 1)[0]
    im_name = im_name if im_name is not None else im_path.ls()[im_idx].name
    mask_name = f'{msk_path}/{im_name}'.replace('png', 'txt')



    # Read the grayscale image
    gray_img = cv2.imread(f'{im_path}/{im_name}', cv2.IMREAD_GRAYSCALE)
    if gray_img is None:
        raise ValueError("Could not read the grayscale image")
    if color is None:
        colors = mpl.colormaps.get_cmap('tab10')



    # Convert image to 3 channels
    rgb_img = np.stack([gray_img]*3, axis=-1)

    image_h, image_w, _ = rgb_img.shape
    fig, ax = plt.subplots()
    ax.imshow(rgb_img)

    with open(f'{mask_name}', 'r') as f:
        for line in f:
            parts = line.strip().split()
            category_id = int(parts[0])
            color = colors(category_id  %10) if color is None else color

            x_center, y_center, width, height = [float(coord) for coord in parts[1:]]

            bottom_left = ((x_center - width/2) * image_w, (y_center - height/2) * image_h)
            bbox_w, bbox_h = width * image_w, height * image_h

            patch = patches.Rectangle(bottom_left, bbox_w, bbox_h, fill=fill, color=color, alpha=alpha)
            ax.add_patch(patch)
    plt.axis('off')
    plt.title('Image with mask')
    plt.show()
get_name = np.vectorize(lambda x: Path(x).name)

# %% ../nbs/02_viz_utils.ipynb 13
def overlay_mask(
        im_path, 
        msk_path, 
        overlay_clr=(0, 1, 0),
        scale=1,
        alpha=0.5,
        ):
    'Creaete a overlay image from image and mask'
    # Read the grayscale image
    gray_img = cv2.imread(f'{im_path}', cv2.IMREAD_GRAYSCALE)
    if gray_img is None:
        raise ValueError("Could not read the grayscale image")

    # Read the mask image
    mask_img = cv2.imread(f'{msk_path}', cv2.IMREAD_GRAYSCALE)
    mask_img = mask_img.astype(bool)
    if mask_img is None:
        raise ValueError("Could not read the mask image")

    # Check if dimensions of both images are the same
    if gray_img.shape != mask_img.shape:
        raise ValueError("Dimensions of grayscale image and mask do not match")

    # Convert image to 3 channels
    rgb_img = np.stack([gray_img]*3, axis=-1)/255
    fig, ax = plt.subplots()
    ax.imshow(rgb_img)

    clrd_overlay = np.zeros_like(rgb_img)
    clrd_overlay[mask_img]=overlay_clr
    ax.imshow(clrd_overlay, alpha=alpha)





# %% ../nbs/02_viz_utils.ipynb 15
def overlay_mask_border_on_image(im_path, msk_path, border_color=(0, 1, 0), border_width=1):
    """
    Overlays the border of a binary mask on a grayscale image and displays the result using matplotlib.
    
    Args:
    image (numpy.ndarray): Grayscale image.
    mask (numpy.ndarray): Binary mask of the same size as the image.
    border_color (tuple): RGB color for the mask border in the range [0, 1].
    border_width (int): Width of the border.
    
    Returns:
    None: The function displays a plot.
    """
    gray_img = cv2.imread(f'{im_path}', cv2.IMREAD_GRAYSCALE)
    if gray_img is None:
        raise ValueError("Could not read the grayscale image")

    # Read the mask image
    mask_img = cv2.imread(f'{msk_path}', cv2.IMREAD_GRAYSCALE)
    mask_img = mask_img.astype(bool)
    if mask_img is None:
        raise ValueError("Could not read the mask image")

    # Check if dimensions of both images are the same
    if gray_img.shape != mask_img.shape:
        raise ValueError("Dimensions of grayscale image and mask do not match")
    # Ensure the mask is boolean

    # Find the borders of the mask
    dilated_mask = binary_dilation(mask_img, iterations=border_width)
    eroded_mask = binary_erosion(mask_img, iterations=border_width)
    border = dilated_mask & ~eroded_mask

    # Convert grayscale image to RGB
    rgb_image = np.stack([gray_img]*3, axis=-1) / 255.0  # Normalize for matplotlib

    # Apply the colored border
    rgb_image[border] = border_color

    # Display the image using matplotlib
    plt.imshow(rgb_image, cmap='gray')
    plt.axis('off')  # Turn off axis numbers
    plt.show()



# %% ../nbs/02_viz_utils.ipynb 20
def overlay_yolo_mask(
        im_path, 
        msk_path, 
        color=None, # color values other matplotlib colors
        idx=None, # Index of image in the folder other random will be chosen
        im_name=None, # Imge name with extension
        fill=False, # whther to fill the mask or not
        alpha=0.3 # alpha value for the mask for transparency
        ):
    'Creaete a overlay image from image and mask'


    im_idx = idx if idx is not None else np.random.choice(len(im_path.ls()), 1)[0]
    im_name = im_name if im_name is not None else im_path.ls()[im_idx].name
    mask_name = f'{msk_path}/{im_name}'.replace('png', 'txt')



    # Read the grayscale image
    gray_img = cv2.imread(f'{im_path}/{im_name}', cv2.IMREAD_GRAYSCALE)
    if gray_img is None:
        raise ValueError("Could not read the grayscale image")
    if color is None:
        colors = mpl.colormaps.get_cmap('tab10')



    # Convert image to 3 channels
    rgb_img = np.stack([gray_img]*3, axis=-1)

    image_h, image_w, _ = rgb_img.shape
    fig, ax = plt.subplots()
    ax.imshow(rgb_img)

    with open(f'{mask_name}', 'r') as f:
        for line in f:
            parts = line.strip().split()
            category_id = int(parts[0])
            color = colors(category_id  %10) if color is None else color

            polygon = [float(coord) for coord in parts[1:]]
            polygon = np.array(polygon).reshape(-1, 2) * np.array([image_w, image_h])
            patch = patches.Polygon(polygon, closed=True, edgecolor=color, fill=fill, alpha=alpha, linewidth=3)
            ax.add_patch(patch)
    plt.axis('off')
    plt.title('Image with mask')
    plt.show()
